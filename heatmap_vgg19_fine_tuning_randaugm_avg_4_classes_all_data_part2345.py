# -*- coding: utf-8 -*-
"""HEATMAP VGG19 fine-tuning RandAugm avg 4 classes all_data  part2345.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cf89rjsgN6nGdejau5NG3_xF3bK6EQI3
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.image import imread
import tensorflow as tf
import pandas as pd
import random
from keras.models import load_model

pip install opencv-python-headless

gpu_info = !nvidia-smi
gpu_info = '\n'.join(gpu_info)
if gpu_info.find('failed') >= 0:
  print('Select the Runtime > "Change runtime type" menu to enable a GPU accelerator, ')
  print('and then re-execute this cell.')
else:
  print(gpu_info)

"""Keras guide:

https://keras.io/guides/transfer_learning/
"""

from google.colab import drive
drive.mount('/content/drive')

test_dir = '/content/drive/My Drive/Colab Notebooks/Mestrado final/RXT teste mix_data/'

tf.io.gfile.listdir(test_dir)

image_shape = (224,224,3)
batch_size = 32

from tensorflow.keras.preprocessing.image import ImageDataGenerator

image_gen = ImageDataGenerator()

image_gen.flow_from_directory(test_dir)

from sklearn.utils import shuffle
test_image_gen = image_gen.flow_from_directory(test_dir,
                                                     #target_size=image_shape[:2],
                                                     color_mode='rgb',
                                                     batch_size=batch_size,
                                                     class_mode='categorical',
                                                     shuffle=False
                                               )

test_image_gen.class_indices

"""**Loading the model**"""

model = tf.keras.models.load_model('/content/drive/My Drive/Colab Notebooks/Mestrado final/Novos treinamentos/KFolds mix aumentado/VGG19_fine-tuning_RandAugm_avg_4_classes_mix_data_part2345.h5')

model.summary()

model.evaluate(test_image_gen)

pred_probabilities = model.predict(test_image_gen)

test_image_gen.class_indices

test_image_gen.classes

def int_predict (pred_probabilities):
  predictions = np.zeros((pred_probabilities.shape[0],1),dtype=int)
  i = 0
  while i < pred_probabilities.shape[0]:
    predictions[i,:] = [np.argmax(pred_probabilities[i])]
    i = i + 1

  return predictions

predictions = int_predict(pred_probabilities)

from sklearn.metrics import classification_report, confusion_matrix

test_image_gen.class_indices

confusion_matrix(test_image_gen.classes,predictions)

print(classification_report(test_image_gen.classes,predictions))

from sklearn.metrics import roc_curve, auc
from sklearn.preprocessing import label_binarize
from itertools import cycle

y_score = pred_probabilities
num_classes = test_image_gen.num_classes

# Obtenha as etiquetas verdadeiras de todas as imagens no gerador
y_test = test_image_gen.classes
y_test = label_binarize(y_test, classes=range(num_classes))

# Calcule as métricas ROC e AUC para cada classe
fpr = dict()
tpr = dict()
roc_auc = dict()
for i in range(num_classes):
    fpr[i], tpr[i], _ = roc_curve(y_test[:, i], y_score[:, i])
    roc_auc[i] = auc(fpr[i], tpr[i])

# Plote a curva ROC para cada classe
colors = cycle(['aqua', 'darkorange', 'cornflowerblue', 'green'])
for i, color in zip(range(num_classes), colors):
    plt.plot(fpr[i], tpr[i], color=color, lw=2,
             label='ROC curve of class {0} (area = {1:0.2f})'
             ''.format(i, roc_auc[i]))

plt.plot([0, 1], [0, 1], 'k--', lw=2)
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver operating characteristic for multi-class')
plt.legend(loc="lower right")
plt.show()

# Agora, vamos dar zoom em na parte superior esquerda do gráfico.
plt.figure()
for i, color in zip(range(num_classes), colors):
    plt.plot(fpr[i], tpr[i], color=color, lw=2,
             label='ROC curve of class {0} (area = {1:0.2f})'
             ''.format(i, roc_auc[i]))

plt.plot([0, 1], [0, 1], 'k--', lw=2)
plt.xlim([0.0, 0.2])  # Ajusta o limite do eixo X para focar no início do gráfico
plt.ylim([0.8, 1.05])  # Ajusta o limite do eixo Y para focar na parte superior do gráfico
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Zoom na parte superior da Receiver operating characteristic to multi-class')
plt.legend(loc="lower right")
plt.show()

#from google.colab import runtime
#runtime.unassign()

# nome da última camada de convolução
last_conv_layer_name = 'block5_conv4'

def make_gradcam_heatmap(img_array, model, last_conv_layer_name):
    # Prepare o modelo para extrair os dados necessários
    last_conv_layer = model.get_layer(last_conv_layer_name)
    last_conv_layer_model = tf.keras.Model(model.inputs, last_conv_layer.output)

    # Cria um modelo que mapeia as ativações da última camada convolucional para a saída final
    classifier_input = tf.keras.Input(shape=last_conv_layer.output.shape[1:])
    x = classifier_input
    for layer in model.layers[model.layers.index(last_conv_layer)+1:]:
        x = layer(x)
    classifier_model = tf.keras.Model(classifier_input, x)

    with tf.GradientTape() as tape:
        # Forward pass
        last_conv_layer_output = last_conv_layer_model(img_array)
        tape.watch(last_conv_layer_output)
        preds = classifier_model(last_conv_layer_output)
        top_pred_index = tf.argmax(preds[0])
        top_class_channel = preds[:, top_pred_index]

    # Calcula os gradientes
    grads = tape.gradient(top_class_channel, last_conv_layer_output)

    # Processamento adicional para evitar problemas de dimensionamento
    if grads is None:
        raise ValueError("Nenhum gradiente foi retornado pelo GradientTape.")

    if len(grads.shape) != 4:
        grads = tf.reshape(grads, [-1, 1, 1, grads.shape[-1]])

    # Ponderação por média do gradiente
    pooled_grads = tf.reduce_mean(grads, axis=(0, 1, 2))

    # Multiplica cada canal no mapa de características
    last_conv_layer_output = last_conv_layer_output.numpy()[0]
    pooled_grads = pooled_grads.numpy()
    for i in range(pooled_grads.shape[-1]):
        last_conv_layer_output[:, :, i] *= pooled_grads[i]

    heatmap = np.mean(last_conv_layer_output, axis=-1)
    heatmap = np.maximum(heatmap, 0) / np.max(heatmap)

    return heatmap

def superimpose_heatmap(heatmap, original_image, alpha=0.4):
    # Inverter os valores do heatmap
    heatmap = np.max(heatmap) - heatmap

    # Normalizar o heatmap
    heatmap = np.uint8(255 * heatmap)
    heatmap = cv2.resize(heatmap, (original_image.shape[1], original_image.shape[0]))

    # Aplicar o colormap
    heatmap = cv2.applyColorMap(heatmap, cv2.COLORMAP_JET)

    # Superpor o heatmap na imagem original
    superimposed_img = heatmap * alpha + original_image
    superimposed_img = np.clip(superimposed_img, 0, 255).astype(np.uint8)

    return superimposed_img

from tensorflow.keras.applications.vgg19 import preprocess_input
import cv2

# Converta as previsões para um formato adequado se necessário
# Se 'predictions' for um array bidimensional de forma (n_samples, 1), converta-o para um array unidimensional
predictions_flat = predictions.flatten()

# Compare as previsões com as classes reais
incorrect_predictions = np.where(predictions_flat != test_image_gen.classes)[0]

# 'incorrect_predictions' agora contém os índices das imagens que foram classificadas incorretamente
print("Índices das previsões incorretas:", incorrect_predictions)

# Se quiser ver as classes reais e as previsões para esses casos:
for idx in incorrect_predictions:
    print(f"Índice: {idx}, Classe Real: {test_image_gen.classes[idx]}, Previsão: {predictions_flat[idx]}")

# Mapeia cada classe ao seu índice inicial
offsets = {0: 0, 1: 83, 2: 129, 3: 213}

# Exibir resultados ajustados
for idx in incorrect_predictions:
    real_class = test_image_gen.classes[idx]
    indice_ajustado = idx - offsets[real_class]
    print(f"Classe {real_class}: Índice na Classe: {indice_ajustado}, Índice Geral: {idx}, Previsão: {predictions_flat[idx]}")

image_name = tf.io.gfile.listdir(test_dir+'covid')[1]
covid19 = test_dir+'covid/'+image_name
covid19_img_array = cv2.imread(covid19)

test_image_gen.class_indices

# Gera o heatmap
heatmap = make_gradcam_heatmap(np.expand_dims(covid19_img_array, axis=0), model, last_conv_layer_name)

# Sobrepõe o heatmap na imagem original
img_with_heatmap = superimpose_heatmap(heatmap, covid19_img_array)

"""Comparison of a chest X-ray from the test group with COVID-19 (first) with the Grad-CAM Heatmap (second). The model accurately highlighted the area of interest and correctly made the classification."""

plt.imshow(covid19_img_array)

# Mostra a imagem com o heatmap
plt.imshow(img_with_heatmap)
plt.show()

image_name = tf.io.gfile.listdir(test_dir+'dip')[4]
covid19 = test_dir+'dip/'+image_name
covid19_img_array = cv2.imread(covid19)

test_image_gen.class_indices

# Gera o heatmap
heatmap = make_gradcam_heatmap(np.expand_dims(covid19_img_array, axis=0), model, last_conv_layer_name)

# Sobrepõe o heatmap na imagem original
img_with_heatmap = superimpose_heatmap(heatmap, covid19_img_array)

"""Comparison of a chest X-ray from the test group with fibrosing ILD (first) with the Grad-CAM Heatmap (second). The model placed greater importance on the correct area of interest and accurately made the classification, despite also focusing on incorrect areas."""

plt.imshow(covid19_img_array)

# Mostra a imagem com o heatmap
plt.imshow(img_with_heatmap)
plt.show()

image_name = tf.io.gfile.listdir(test_dir+'dip')[6]
covid19 = test_dir+'dip/'+image_name
covid19_img_array = cv2.imread(covid19)

test_image_gen.class_indices

# Gera o heatmap
heatmap = make_gradcam_heatmap(np.expand_dims(covid19_img_array, axis=0), model, last_conv_layer_name)

# Sobrepõe o heatmap na imagem original
img_with_heatmap = superimpose_heatmap(heatmap, covid19_img_array)

"""Comparison of a chest X-ray from the test group with granulomatous ILD (first) with the Grad-CAM Heatmap (second). The model accurately highlighted the area of interest and correctly made the classification."""

plt.imshow(covid19_img_array)

# Mostra a imagem com o heatmap
plt.imshow(img_with_heatmap)
plt.show()

image_name = tf.io.gfile.listdir(test_dir+'tuberculose')[23]
covid19 = test_dir+'tuberculose/'+image_name
covid19_img_array = cv2.imread(covid19)

test_image_gen.class_indices

# Gera o heatmap
heatmap = make_gradcam_heatmap(np.expand_dims(covid19_img_array, axis=0), model, last_conv_layer_name)

# Sobrepõe o heatmap na imagem original
img_with_heatmap = superimpose_heatmap(heatmap, covid19_img_array)

"""Comparison of a chest X-ray from the test group with tuberculosis (first) with the Grad-CAM Heatmap (second). The model accurately highlighted the correct area of interest and successfully made the classification."""

plt.imshow(covid19_img_array)

# Mostra a imagem com o heatmap
plt.imshow(img_with_heatmap)
plt.show()

image_name = tf.io.gfile.listdir(test_dir+'covid')[80]
covid19 = test_dir+'covid/'+image_name
covid19_img_array = cv2.imread(covid19)

test_image_gen.class_indices

# Gera o heatmap
heatmap = make_gradcam_heatmap(np.expand_dims(covid19_img_array, axis=0), model, last_conv_layer_name)

# Sobrepõe o heatmap na imagem original
img_with_heatmap = superimpose_heatmap(heatmap, covid19_img_array)

"""Chest X-ray from the test group with COVID-19 (first) alongside the Grad-CAM Heatmap (second). The model misclassified it as 'tuberculosis'."""

plt.imshow(covid19_img_array)

# Mostra a imagem com o heatmap
plt.imshow(img_with_heatmap)
plt.show()